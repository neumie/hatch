#!/usr/bin/env bash
# docker.sh - Docker Compose management
# Depends on: core.sh, manifest.sh, ports.sh

# hatch_write_env WORKSPACE_NAME
# Writes .env file with WORKSPACE_NAME and all PORT_* variables
# Used for Docker Compose variable interpolation
hatch_write_env() {
  local workspace_name="$1"
  local env_file=".env"

  _info "Writing Docker Compose .env file"

  {
    echo "# Generated by hatch - do not edit manually"
    echo "WORKSPACE_NAME=$workspace_name"
    echo ""
    echo "# Port allocations"

    # Export all HATCH_PORT_* variables as PORT_*
    while IFS='=' read -r var_name var_value; do
      if [[ "$var_name" =~ ^HATCH_PORT_ ]]; then
        local service_name=${var_name#HATCH_PORT_}
        echo "PORT_${service_name}=${var_value}"
      fi
    done < <(env | grep '^HATCH_PORT_' | sort)

    # Export per-container-port mappings (HATCH_PORTMAP_* -> PORTMAP_*)
    echo ""
    echo "# Per-container-port mappings"
    while IFS='=' read -r var_name var_value; do
      if [[ "$var_name" =~ ^HATCH_PORTMAP_ ]]; then
        echo "${var_name#HATCH_}=${var_value}"
      fi
    done < <(env | grep '^HATCH_PORTMAP_' | sort)
  } > "$env_file"

  _success "Created $env_file"
}

# _emit_docker_env SERVICE_NAME
# Checks DOCKER_ENV for entries matching this service and emits environment: block
# Format: "service_name:VAR=value_with_{PORT_*}_placeholders"
# Resolves {PORT_*} to ${PORT_*} for Docker Compose .env interpolation
_emit_docker_env() {
  local target_service="$1"
  local has_env=0

  if [[ -z "${DOCKER_ENV:-}" ]]; then
    return
  fi

  while IFS= read -r env_spec; do
    [[ -z "$env_spec" ]] && continue

    local svc_name env_assignment
    svc_name=$(echo "$env_spec" | cut -d: -f1)
    env_assignment=$(echo "$env_spec" | cut -d: -f2-)

    if [[ "$svc_name" == "$target_service" ]]; then
      if [[ $has_env -eq 0 ]]; then
        echo "    environment:"
        has_env=1
      fi

      local var_name var_value
      var_name=$(echo "$env_assignment" | cut -d= -f1)
      var_value=$(echo "$env_assignment" | cut -d= -f2-)

      # Resolve {PORT_*} to ${PORT_*} for Docker Compose interpolation
      # Build sed expression for all matches in one pass to avoid infinite loop
      # (replacing {PORT_x} with ${PORT_x} would re-match the {PORT_x} substring)
      local sed_expr=""
      local tmp_value="$var_value"
      while [[ "$tmp_value" =~ \{PORT_([^}]+)\} ]]; do
        local port_service="${BASH_REMATCH[1]}"
        local port_safe
        port_safe=$(_sanitize_var_name "$port_service")
        sed_expr="${sed_expr}s/{PORT_${port_service}}/\${PORT_${port_safe}}/g;"
        # Remove the matched portion to find additional patterns
        tmp_value="${tmp_value#*\}}"
      done
      if [[ -n "$sed_expr" ]]; then
        var_value=$(echo "$var_value" | sed "$sed_expr")
      fi

      echo "      ${var_name}: \"${var_value}\""
    fi
  done < <(_parse_services DOCKER_ENV)
}

# hatch_write_docker_override WORKSPACE_NAME
# Generates docker-compose.override.yaml dynamically from manifest
# Reads DOCKER_SERVICES, DOCKER_EXTRAS, and DOCKER_ENV
# Creates isolated containers with workspace-specific names and port mappings
hatch_write_docker_override() {
  local workspace_name="$1"
  local override_file="docker-compose.override.yaml"

  _info "Generating docker-compose.override.yaml"

  # Start YAML file
  {
    echo "# Generated by hatch - do not edit manually"
    echo "# Workspace: $workspace_name"
    echo ""
    echo "services:"

    # Process Docker services
    while IFS= read -r service_spec; do
      [[ -z "$service_spec" ]] && continue

      # Parse format: "name:port" or "name:port,port2,port3"
      local service_name container_ports safe_name
      service_name=$(echo "$service_spec" | cut -d: -f1)
      container_ports=$(echo "$service_spec" | cut -d: -f2)
      safe_name=$(_sanitize_var_name "$service_name")

      echo "  ${service_name}:"
      echo "    container_name: \${WORKSPACE_NAME}-${service_name}"
      echo "    ports: !override"

      # Each container port maps to its own host port via PORTMAP variable
      IFS=',' read -ra ports <<< "$container_ports"
      for container_port in "${ports[@]}"; do
        echo "      - \"\${PORTMAP_${safe_name}_${container_port}}:${container_port}\""
      done

      # Emit environment overrides if configured
      _emit_docker_env "$service_name"

      echo ""
    done < <(_parse_services DOCKER_SERVICES)

    # Process Docker extras
    while IFS= read -r service_spec; do
      [[ -z "$service_spec" ]] && continue

      local service_name container_ports safe_name
      service_name=$(echo "$service_spec" | cut -d: -f1)
      container_ports=$(echo "$service_spec" | cut -d: -f2)
      safe_name=$(_sanitize_var_name "$service_name")

      echo "  ${service_name}:"
      echo "    container_name: \${WORKSPACE_NAME}-${service_name}"
      echo "    ports: !override"

      # Each container port maps to its own host port via PORTMAP variable
      IFS=',' read -ra ports <<< "$container_ports"
      for container_port in "${ports[@]}"; do
        echo "      - \"\${PORTMAP_${safe_name}_${container_port}}:${container_port}\""
      done

      # Emit environment overrides if configured
      _emit_docker_env "$service_name"

      echo ""
    done < <(_parse_services DOCKER_EXTRAS)

  } > "$override_file"

  _success "Created $override_file"
}

# hatch_docker_up
# Starts Docker Compose services in detached mode
# If startup fails with a port conflict, tears down and retries once
hatch_docker_up() {
  _header "Starting Docker services"

  if ! command -v docker >/dev/null 2>&1; then
    _die "Docker not found. Install Docker Desktop or Docker Engine."
  fi

  # Check if docker daemon is running
  if ! docker info >/dev/null 2>&1; then
    _die "Docker daemon is not running. Start Docker Desktop or the Docker service."
  fi

  # Run docker compose up, capturing stderr for error analysis
  local compose_output
  if compose_output=$(docker compose up --detach 2>&1); then
    [[ -n "$compose_output" ]] && echo "$compose_output"
    _success "Docker services started"
    return 0
  fi

  # Check if failure was a port conflict
  if echo "$compose_output" | grep -qiE "port is already allocated|address already in use|Bind for .* failed"; then
    _warn "Port conflict detected during startup. Cleaning up and retrying..."

    # Extract and report the specific conflicting port
    local conflicting_port
    conflicting_port=$(echo "$compose_output" | grep -oE "Bind for 0\.0\.0\.0:[0-9]+" | head -1 | grep -oE "[0-9]+$")
    if [[ -n "$conflicting_port" ]]; then
      _error "Conflict on port: $conflicting_port"
      _report_port_user "$conflicting_port"
    fi

    # Tear down any partially-started containers
    docker compose down --timeout 5 2>/dev/null || true

    # Clean stale registry entries
    _port_registry_clean 2>/dev/null || true

    # Brief pause to allow ports to be released after teardown
    sleep 1

    # Re-check port availability and report conflicts
    _info "Checking for external port conflicts..."
    local has_external_conflict=0
    while IFS='=' read -r var_name var_value; do
      if [[ "$var_name" =~ ^HATCH_PORTMAP_ ]]; then
        if _check_port "$var_value"; then
          local label=${var_name#HATCH_PORTMAP_}
          _error "Port $var_value ($label) is still in use"
          _report_port_user "$var_value"
          has_external_conflict=1
        fi
      fi
    done < <(env | grep '^HATCH_PORTMAP_')

    if [[ $has_external_conflict -eq 1 ]]; then
      _die "External port conflicts remain. Stop the conflicting services or use a different workspace name."
    fi

    # Retry once after cleanup
    _info "Retrying docker compose up..."
    if docker compose up --detach; then
      _success "Docker services started (after retry)"
      return 0
    else
      _die "Failed to start Docker services"
    fi
  fi

  # Non-port-related failure
  echo "$compose_output" >&2
  _die "Failed to start Docker services"
}

# hatch_docker_stop
# Stops Docker Compose services without removing containers or volumes
hatch_docker_stop() {
  _header "Stopping Docker services"

  if ! command -v docker >/dev/null 2>&1; then
    _warn "Docker not found, skipping"
    return 0
  fi

  if docker compose stop; then
    _success "Docker services stopped"
    return 0
  else
    _error "Failed to stop Docker services"
    return 1
  fi
}

# hatch_docker_down
# Stops and removes Docker Compose services
hatch_docker_down() {
  _header "Stopping Docker services"

  if ! command -v docker >/dev/null 2>&1; then
    _warn "Docker not found, skipping"
    return 0
  fi

  if docker compose down; then
    _success "Docker services stopped"
    return 0
  else
    _error "Failed to stop Docker services"
    return 1
  fi
}

# hatch_docker_status
# Returns Docker Compose status in table format
# Output: table with Name and Status columns
hatch_docker_status() {
  if ! command -v docker >/dev/null 2>&1; then
    echo "Docker not installed"
    return 1
  fi

  if ! docker info >/dev/null 2>&1; then
    echo "Docker daemon not running"
    return 1
  fi

  # Check if compose file exists
  if ! docker compose config >/dev/null 2>&1; then
    echo "No docker-compose.yaml found"
    return 1
  fi

  docker compose ps --format "table {{.Name}}\t{{.Status}}"
}

# hatch_docker_running
# Returns 0 if docker services are running, 1 otherwise
# Useful for conditional checks
hatch_docker_running() {
  if ! command -v docker >/dev/null 2>&1; then
    return 1
  fi

  if ! docker info >/dev/null 2>&1; then
    return 1
  fi

  # Check if any containers are running
  local running_containers
  running_containers=$(docker compose ps --quiet 2>/dev/null)

  if [[ -n "$running_containers" ]]; then
    return 0
  else
    return 1
  fi
}
