#!/usr/bin/env bash
# docker.sh - Docker Compose management
# Depends on: core.sh, manifest.sh, ports.sh

# hatch_write_env WORKSPACE_NAME
# Writes .env file with WORKSPACE_NAME and all PORT_* variables
# Used for Docker Compose variable interpolation
hatch_write_env() {
  local workspace_name="$1"
  local env_file=".env"

  _info "Writing Docker Compose .env file"

  {
    echo "# Generated by hatch - do not edit manually"
    echo "WORKSPACE_NAME=$workspace_name"
    echo ""
    echo "# Port allocations"

    # Export all HATCH_PORT_* variables as PORT_*
    while IFS='=' read -r var_name var_value; do
      if [[ "$var_name" =~ ^HATCH_PORT_ ]]; then
        local service_name=${var_name#HATCH_PORT_}
        echo "PORT_${service_name}=${var_value}"
      fi
    done < <(env | grep '^HATCH_PORT_' | sort)
  } > "$env_file"

  _success "Created $env_file"
}

# hatch_write_docker_override WORKSPACE_NAME
# Generates docker-compose.override.yaml dynamically from manifest
# Reads DOCKER_SERVICES and DOCKER_EXTRAS
# Creates isolated containers with workspace-specific names and port mappings
hatch_write_docker_override() {
  local workspace_name="$1"
  local override_file="docker-compose.override.yaml"

  _info "Generating docker-compose.override.yaml"

  # Start YAML file
  {
    echo "# Generated by hatch - do not edit manually"
    echo "# Workspace: $workspace_name"
    echo ""
    echo "services:"

    # Process Docker services
    while IFS= read -r service_spec; do
      [[ -z "$service_spec" ]] && continue

      # Parse format: "name:port" or "name:port,port2,port3"
      local service_name container_ports safe_name
      service_name=$(echo "$service_spec" | cut -d: -f1)
      container_ports=$(echo "$service_spec" | cut -d: -f2)
      safe_name=$(_sanitize_var_name "$service_name")

      echo "  ${service_name}:"
      echo "    container_name: \${WORKSPACE_NAME}-${service_name}"
      echo "    ports: !override"

      # Handle multiple ports (comma-separated)
      IFS=',' read -ra ports <<< "$container_ports"
      for container_port in "${ports[@]}"; do
        echo "      - \"\${PORT_${safe_name}}:${container_port}\""
      done

      echo ""
    done < <(_parse_services DOCKER_SERVICES)

    # Process Docker extras
    while IFS= read -r service_spec; do
      [[ -z "$service_spec" ]] && continue

      local service_name container_ports safe_name
      service_name=$(echo "$service_spec" | cut -d: -f1)
      container_ports=$(echo "$service_spec" | cut -d: -f2)
      safe_name=$(_sanitize_var_name "$service_name")

      echo "  ${service_name}:"
      echo "    container_name: \${WORKSPACE_NAME}-${service_name}"
      echo "    ports: !override"

      # Handle multiple ports (comma-separated)
      IFS=',' read -ra ports <<< "$container_ports"
      for container_port in "${ports[@]}"; do
        echo "      - \"\${PORT_${safe_name}}:${container_port}\""
      done

      echo ""
    done < <(_parse_services DOCKER_EXTRAS)

  } > "$override_file"

  _success "Created $override_file"
}

# hatch_docker_up
# Starts Docker Compose services in detached mode
hatch_docker_up() {
  _header "Starting Docker services"

  if ! command -v docker >/dev/null 2>&1; then
    _die "Docker not found. Install Docker Desktop or Docker Engine."
  fi

  # Check if docker daemon is running
  if ! docker info >/dev/null 2>&1; then
    _die "Docker daemon is not running. Start Docker Desktop or the Docker service."
  fi

  # Run docker compose up
  if docker compose up --detach; then
    _success "Docker services started"
    return 0
  else
    _die "Failed to start Docker services"
  fi
}

# hatch_docker_down
# Stops Docker Compose services
hatch_docker_down() {
  _header "Stopping Docker services"

  if ! command -v docker >/dev/null 2>&1; then
    _warn "Docker not found, skipping"
    return 0
  fi

  if docker compose down; then
    _success "Docker services stopped"
    return 0
  else
    _error "Failed to stop Docker services"
    return 1
  fi
}

# hatch_docker_status
# Returns Docker Compose status in table format
# Output: table with Name and Status columns
hatch_docker_status() {
  if ! command -v docker >/dev/null 2>&1; then
    echo "Docker not installed"
    return 1
  fi

  if ! docker info >/dev/null 2>&1; then
    echo "Docker daemon not running"
    return 1
  fi

  # Check if compose file exists
  if ! docker compose config >/dev/null 2>&1; then
    echo "No docker-compose.yaml found"
    return 1
  fi

  docker compose ps --format "table {{.Name}}\t{{.Status}}"
}

# hatch_docker_running
# Returns 0 if docker services are running, 1 otherwise
# Useful for conditional checks
hatch_docker_running() {
  if ! command -v docker >/dev/null 2>&1; then
    return 1
  fi

  if ! docker info >/dev/null 2>&1; then
    return 1
  fi

  # Check if any containers are running
  local running_containers
  running_containers=$(docker compose ps --quiet 2>/dev/null)

  if [[ -n "$running_containers" ]]; then
    return 0
  else
    return 1
  fi
}
