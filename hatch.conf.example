#!/usr/bin/env bash

################################################################################
# HATCH CONFIGURATION EXAMPLE
################################################################################
#
# This is a fully documented example hatch.conf for a typical full-stack SaaS
# application with:
#   - Next.js frontend
#   - NestJS API
#   - Background worker
#   - PostgreSQL database
#   - Redis cache
#   - Mailhog for email testing
#
# Copy this file to your project root as `hatch.conf` and customize it.
#
################################################################################

# ==============================================================================
# PROJECT IDENTITY
# ==============================================================================

# PROJECT_NAME: The name of your project (used for display and logging)
# Typically derived from git repository name (e.g., "my-saas-app")
PROJECT_NAME="acme-saas"

# PACKAGE_MANAGER: Which package manager to use for dependency installation
# Valid values: "yarn", "pnpm", "npm", "bun", "none"
# Detection: Check for yarn.lock, pnpm-lock.yaml, package-lock.json, bun.lockb
PACKAGE_MANAGER="pnpm"

# ==============================================================================
# DOCKER SERVICES (Infrastructure)
# ==============================================================================

# DOCKER_SERVICES: Infrastructure services with no web UI
# Format: "service_name:container_port[,additional_ports]"
#
# These are started via `hatch docker:up` and must be defined in docker-compose.yaml
# The ports listed here are the container ports (left side of docker ports mapping)
#
# Common services:
#   - postgres:5432
#   - mysql:3306
#   - mongodb:27017
#   - redis:6379
#   - rabbitmq:5672,15672
#   - elasticsearch:9200,9300
#
DOCKER_SERVICES="
  postgres:5432
  redis:6379
"

# DOCKER_EXTRAS: Development tools with web UIs
# Format: Same as DOCKER_SERVICES
#
# These are optional services for development convenience
# They're excluded from production but useful for local dev
#
# Common extras:
#   - mailhog:8025,1025 (SMTP testing)
#   - adminer:8080 (Database management)
#   - pgadmin:5050 (PostgreSQL admin)
#   - redis-commander:8081 (Redis browser)
#
DOCKER_EXTRAS="
  mailhog:8025
"

# ==============================================================================
# DEVELOPMENT SERVERS
# ==============================================================================

# DEV_SERVERS: Application servers to run during development
# Format: "name:directory:command:port_offset"
#
# - name: Identifier for this server (used in port templates as {PORT_name})
# - directory: Relative path from project root to run command
# - command: Shell command to start server (use {PORT} placeholder)
# - port_offset: Unique number >=10 (0-9 reserved for docker services)
#
# Port calculation: BASE_PORT (default 1481) + port_offset = actual port
# Example: BASE_PORT=1481, offset=10 → server runs on port 1491
#
# The {PORT} placeholder is replaced with the calculated port at runtime
#
# Common frameworks:
#   - Vite: "vite dev --host --port {PORT}"
#   - Next.js: "next dev -p {PORT}"
#   - NestJS: "nest start --watch" (reads PORT from env)
#   - Nuxt: "nuxt dev --port {PORT}"
#   - Django: "python manage.py runserver {PORT}"
#   - Rails: "rails server -p {PORT}"
#
DEV_SERVERS="
  web:apps/web:pnpm --filter web dev -p {PORT}:10
  api:apps/api:pnpm --filter api start:dev:11
  worker:apps/worker:node dist/main.js:12
"

# ==============================================================================
# PORT TEMPLATES
# ==============================================================================

# PORT_TEMPLATES: Environment files containing localhost URLs to templatize
# Format: Array of file paths (relative to project root)
#
# Hatch will:
#   1. Look for corresponding .template files (e.g., .env.local.template)
#   2. Replace {PORT_servicename} placeholders with actual ports
#   3. Generate the real files (e.g., .env.local)
#
# Template syntax:
#   {PORT_servicename} - Replaced with port for named service
#   servicename must match:
#     - A dev server name from DEV_SERVERS
#     - A docker service name from DOCKER_SERVICES/DOCKER_EXTRAS
#
# Example .env.local.template:
#   NEXT_PUBLIC_API_URL=http://localhost:{PORT_api}/api
#   DATABASE_URL=postgresql://user:pass@localhost:{PORT_postgres}/db
#   REDIS_URL=redis://localhost:{PORT_redis}
#   SMTP_HOST=localhost
#   SMTP_PORT={PORT_mailhog}
#
PORT_TEMPLATES="
  apps/web/.env.local:NEXT_PUBLIC_API_URL=http://localhost:{PORT_api}/api
  apps/api/.env.local:DATABASE_URL=postgresql://user:pass@localhost:{PORT_postgres}/db
  apps/worker/.env.local:REDIS_URL=redis://localhost:{PORT_redis}
"

# ==============================================================================
# MCP SERVERS
# ==============================================================================

# MCP_SERVERS: Model Context Protocol server definitions
# Format: "name:command:args"
#
# Hatch writes MCP config to ~/.claude.json (project-scoped, user-local)
# with resolved ports so MCP servers can connect to workspace-specific services.
#
# - name: Server identifier (must match entries in MCP_ENV)
# - command: Executable (e.g., "npx", "node", "python")
# - args: Space-separated arguments to the command
#
# Common patterns:
#   - TypeScript MCP: "my-server:npx:tsx mcp/host/src/index.ts"
#   - Node MCP: "my-server:node:mcp/server.js"
#   - Python MCP: "my-server:python:mcp/server.py"
#
MCP_SERVERS="
  acme-mcp:npx:tsx mcp/host/src/index.ts
"

# MCP_ENV: Environment variables passed to MCP servers
# Format: "server_name:KEY=value"
#
# Supports {PORT_servicename} placeholders — resolved to workspace-specific ports.
# Also supports {DOCKER_HOST} — resolved to host.docker.internal (macOS) or 172.17.0.1 (Linux).
#
# These env vars are written into the mcpServers config in ~/.claude.json.
# The MCP server reads them via process.env at startup.
#
MCP_ENV="
  acme-mcp:API_URL=http://localhost:{PORT_api}/api
  acme-mcp:DATABASE_URL=postgresql://user:pass@localhost:{PORT_postgres}/db
  acme-mcp:ENVIRONMENT=local
"

# ==============================================================================
# DATABASE MIGRATIONS
# ==============================================================================

# MIGRATE_TOOL: Which migration system to use
# Valid values: "prisma", "contember", "knex", "drizzle", "custom", "none"
#
# Built-in tools have predefined commands:
#   - prisma: npx prisma migrate deploy
#   - contember: npm run contember migrations:execute
#   - knex: npx knex migrate:latest
#   - drizzle: npx drizzle-kit migrate
#   - custom: Use MIGRATE_EXECUTE_CMD below
#   - none: Skip migrations
#
MIGRATE_TOOL="prisma"

# MIGRATE_EXECUTE_CMD: Custom migration command (if MIGRATE_TOOL="custom")
# Only required if using custom migration tool
# Will be executed from project root directory
#
# Examples:
#   - "./scripts/run-migrations.sh"
#   - "cd apps/api && npm run migrate"
#   - "docker-compose exec postgres psql -f migrations/schema.sql"
#
# MIGRATE_EXECUTE_CMD="./scripts/migrate.sh"

# MIGRATE_SETUP_CMD: Command to generate new migration (optional)
# Used by `hatch migrate:create` command
# If not set, hatch will use tool-specific defaults
#
# MIGRATE_SETUP_CMD="npx prisma migrate dev --create-only"

# ==============================================================================
# DATABASE CREDENTIALS
# ==============================================================================

# DB_USER: Database username
# Extracted from docker-compose.yaml POSTGRES_USER or equivalent
# Used in migration scripts and connection strings
DB_USER="acme_user"

# DB_PASS: Database password
# Extracted from docker-compose.yaml POSTGRES_PASSWORD or equivalent
DB_PASS="secret_password"

# DB_NAME: Database name
# Extracted from docker-compose.yaml POSTGRES_DB or equivalent
DB_NAME="acme_saas_dev"

# DB_HOST: Database host (optional, default: "localhost")
# DB_HOST="localhost"

# DB_PORT: Database port (optional, default: from DOCKER_SERVICES)
# DB_PORT="5432"

# ==============================================================================
# SETUP STEPS
# ==============================================================================

# SETUP_STEPS: Array of steps to run during `hatch setup`
# Executed in order, stops on first failure
#
# Built-in steps:
#   - docker:up          Start docker services
#   - docker:down        Stop docker services
#   - deps:install       Install package dependencies (uses PACKAGE_MANAGER)
#   - migrate:execute    Run database migrations (uses MIGRATE_TOOL)
#   - migrate:create     Generate new migration
#   - data:import        Import seed/fixture data
#   - data:export        Export data to fixtures
#   - custom:funcname    Call custom function from HOOKS_FILE
#
# Common patterns:
#
# Minimal (just docker + migrations):
#   SETUP_STEPS="docker:up migrate:execute"
#
# Full setup with dependencies and data:
#   SETUP_STEPS="docker:up deps:install migrate:execute data:import"
#
# Monorepo with custom bootstrap:
#   SETUP_STEPS="docker:up custom:setup_workspaces migrate:execute"
#
SETUP_STEPS="docker:up deps:install migrate:execute data:import"

# ==============================================================================
# DATA IMPORT/EXPORT
# ==============================================================================

# DATA_EXPORT_DIR: Directory to store exported data fixtures
# Used by `hatch data:export` command
# Default: "exports" in project root
DATA_EXPORT_DIR="exports"

# DATA_IMPORT_DIR: Directory containing data fixtures to import
# Used by `hatch data:import` command
# Default: Same as DATA_EXPORT_DIR
DATA_IMPORT_DIR="exports"

# DATA_EXPORT_CMD: Custom command to export data (optional)
# If not set, hatch will attempt to use tool-specific defaults
#
# Example:
#   DATA_EXPORT_CMD="pg_dump -U $DB_USER -d $DB_NAME > exports/dump.sql"
#
# DATA_EXPORT_CMD="node scripts/export-fixtures.js"

# DATA_IMPORT_CMD: Custom command to import data (optional)
# If not set, hatch will attempt to use tool-specific defaults
#
# Example:
#   DATA_IMPORT_CMD="psql -U $DB_USER -d $DB_NAME < exports/dump.sql"
#
# DATA_IMPORT_CMD="node scripts/import-fixtures.js"

# ==============================================================================
# CUSTOM HOOKS
# ==============================================================================

# HOOKS_FILE: Path to bash script with custom hook functions
# Relative to project root
#
# Available hooks:
#   - post_setup()    Called after SETUP_STEPS complete
#   - pre_start()     Called before dev servers start
#   - post_start()    Called after dev servers start
#   - pre_stop()      Called before stopping servers
#   - post_stop()     Called after stopping servers
#
# Example hatch.hooks.sh:
#   #!/usr/bin/env bash
#   post_setup() {
#     echo "Generating Prisma client..."
#     cd apps/api && npx prisma generate
#     return 0
#   }
#
HOOKS_FILE="hatch.hooks.sh"

# ==============================================================================
# PORT CONFIGURATION (Advanced)
# ==============================================================================

# BASE_PORT: Starting port for dev servers
# Dev servers use BASE_PORT + port_offset from DEV_SERVERS
# Default: 1481
# BASE_PORT=1481

# DOCKER_PORT_OFFSET: Offset for docker service ports
# Docker services use BASE_PORT + DOCKER_PORT_OFFSET + index
# Default: 0 (uses original ports from docker-compose)
# DOCKER_PORT_OFFSET=0

# ==============================================================================
# ADVANCED OPTIONS
# ==============================================================================

# DOCKER_COMPOSE_FILE: Custom docker-compose file path
# Default: "docker-compose.yaml" (also checks .yml, compose.yaml, compose.yml)
# DOCKER_COMPOSE_FILE="docker/compose.yaml"

# LOG_LEVEL: Logging verbosity
# Valid values: "debug", "info", "warn", "error"
# Default: "info"
# LOG_LEVEL="info"

# AUTO_RESTART: Automatically restart failed dev servers
# Valid values: "true", "false"
# Default: "false"
# AUTO_RESTART="false"

# HEALTH_CHECK_ENABLED: Enable health checks for services
# Valid values: "true", "false"
# Default: "true"
# HEALTH_CHECK_ENABLED="true"

# HEALTH_CHECK_TIMEOUT: Seconds to wait for services to become healthy
# Default: 60
# HEALTH_CHECK_TIMEOUT=60

################################################################################
# END OF CONFIGURATION
################################################################################
#
# After creating your hatch.conf:
#
# 1. Create .template files for any files in PORT_TEMPLATES
#    Example: If PORT_TEMPLATES=("apps/web/.env.local"), create:
#    apps/web/.env.local.template with {PORT_servicename} placeholders
#
# 2. Run `hatch setup` to initialize the project
#    This will execute all SETUP_STEPS
#
# 3. Run `hatch run` to start all dev servers
#    Servers will run on BASE_PORT + their port_offset
#
# 4. Run `hatch stop` to gracefully stop everything
#
# 5. Run `hatch status` to see what's running
#
# For help: `hatch help`
#
################################################################################
